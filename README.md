
# Labyrinth Adventure — Web UI (event-driven)

A compact Python labyrinth crawler with a modern browser UI. The app uses a structured, event-driven engine (no stdout scraping) over Socket.IO; the frontend renders dialogue with typed pacing and menus as buttons.

## Features

- Character creation with selectable difficulty (Easy/Normal/Hard) that sets the roll dice (6d5/5d5/4d5); HP and Gold based on rules and dialogue-driven narration
- Town hub: Shop, Healer, Tavern, Eat, Gamble, Temple (Divine), Level Up, Quests, Train, Sleep, Companion, Repair, Remove Curses, Save
- Labyrinth exploration: generated rooms, traps, ambient flavor, chests, rare item drops, and monster encounters
- Turn-based combat with aimed attacks, potions, spells, divine aid, charm, run, and examine; XP/leveling and loot
- Web UI: button-driven menus, character-by-character reveal, and a compact HUD (can be toggled off)

## Run the web app

```powershell
python -m venv .venv ; .\.venv\Scripts\Activate.ps1
pip install -r requirements.txt

# Build the frontend assets (React JSX → JS)
npm ci
npm run build

python .\web_app.py
```

Then open http://127.0.0.1:5000/ in your browser.

Note: The legacy CLI entry point (`python -m game`) has been removed. Use the web app.

## Responsive scene images (no UI changes)

- Background/foreground scene images are rendered with `<img>` layers using `object-fit: contain` and centered alignment to prevent any cropping on mobile and desktop.
- Images are constrained to the viewport with `max-width: 100vw` and `max-height: 100vh` and do not overflow horizontally or vertically.
- The dynamic textbox (auto-resizing, buttons, starting position, and interactions) is unchanged; only the image container implementation was adjusted.
- The container uses modern viewport units where available (`height: 100dvh`) with a `100vh` fallback to avoid mobile browser UI cropping.

## Dev quick-start

- Python deps: `pip install -r requirements.txt`
- Frontend build: `npm ci && npm run build` (compiles `static/app.jsx` to `static/app.js`)
- Start server: `python .\web_app.py` → open http://127.0.0.1:5000/

## Deploy on Render

This repo includes a Render Blueprint (`render.yaml`) to provision a Web Service with WebSockets.

Environment variables to set on Render:

- MONGODB_URI: Your MongoDB Atlas SRV connection string (no quotes)
- MONGODB_DB: Database name (default: `labyrinth`)
- MONGODB_COLLECTION: Collection name (default: `player_saves`)
- SECRET_KEY: Auto-generated by the blueprint; you can rotate it anytime
- FORCE_SECURE_COOKIES: "1" (ensures the device_id cookie is secure over HTTPS)
- NODE_VERSION: Set to "20" (already in blueprint) for the frontend build

Notes:

- The blueprint build step installs Python deps and runs `npm ci && npm run build` to compile `static/app.jsx` to `static/app.js`.
- WebSockets are enabled via `eventlet` and Socket.IO. Health checks hit `/health`.
- For scale-out (multiple instances), add a Redis and set `SOCKETIO_MESSAGE_QUEUE` to the Redis URL.

Steps:

1) Connect this private repo to Render
2) New > Blueprint > Select this repo > Confirm
3) In the created service, set `MONGODB_URI` in Environment, then Deploy
4) Open the service URL and play

## Diagnostics and tests

- Syntax/import check (all .py): `python tools/check_all.py`
- Dialogue key coverage: `python tools/check_dialogue_references.py`
- Import smoke: `python tools/import_smoke_test.py`
- Combat log tests: `python tools/test_log_strings.py`
- Shop/town flows: `python tools/shop_flow_test.py`, `python tools/shop_purchase_sell_test.py`, `python tools/town_flow_test.py` (some legacy tests may reference removed CLI functions and can be skipped)

## Tips

- All player-facing text comes from `data/dialogues.json` where possible.
- Add content in `data/` (monsters, items, traps, spells) to extend the game.
- The web engine lives in `game/engine.py` and emits events the server forwards to the client.

Localization note: Most roll/result strings are data-driven. Examples include keys for town refresh gating and sleep outcomes (e.g., `town.refresh_used`, `town.sleep_success`, `town.sleep_fail`), and creation narration such as `system.gold_result_detailed`.

For a technical architecture and structure guide, see `project_overview.md`.
For game systems and rules, see `mechanics.md`.